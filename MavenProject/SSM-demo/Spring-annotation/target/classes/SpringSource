Spring容器refresh()【创建刷新】
1.prepareRefresh();刷新前的预处理
        1.initPropertySources();初始化一些属性设置，子类自定义个性化的属性设置方法
        2.getEnvironment().validateRequiredProperties();进行属性校验
        3.this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();保存容器中一些早期的事件
2.obtainFreshBeanFactory();获取bean工厂
        1.refreshBeanFactory();（创建）刷新bean工厂
                创建了一个this.beanFactory = new DefaultListableBeanFactory();
                设置id
        2.getBeanFactory();返回AnnotationConfigApplicationContext创建对象时调用的父类GenericApplicationContext的空参构造器创建的DefaultListableBeanFactory对象
        3.将BeanFactory【DefaultListableBeanFactory】对象返回
3.prepareBeanFactory(beanFactory);BeanFactory的预准备工作（BeanFactory进行一些设置）
        1.设置BeanFactory的类加载器，支持表达式解析器
        2.添加部分的BeanPostProcessor【ApplicationContextAwareProcessor】
        3.设置忽略的自动装配接口EnvironmentAware、EmbeddedValueResolverAware。。。
        4.注册可以解析的自动装配，我们能直接在任何组件中自动注入：ResourceLoader、BeanFactory、ApplicationEventPublisher、ApplicationContext
        5.添加BeanPostProcessor【ApplicationListenerDetector】
        6.添加编译时的AspectJ支持
        7.给容器中注册一些能用的组件：environment【ConfigurableEnvironment】、SystemProperties【Map<String, Object>】、SystemEnvironment【Map<String, Object>】
4.postProcessBeanFactory(beanFactory);BeanFactory准备完成以后的处理工作
        1.子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置
=================================================以上是BeanFactory的创建和预准备工作===================================================
5.invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor
    BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的
    两个接口BeanFactoryPostProcessor，BeanDefinitionRegistryPostProcessor
        1.执行BeanFactoryPostProcessor的方法
            1.获取所有的BeanDefinitionRegistryPostProcessor
            2.看优先级排序PriorityOrdered，先执行实现了这个接口的BeanDefinitionRegistryPostProcessor
                postProcessor.postProcessBeanDefinitionRegistry(registry);
            3.再执行实现了Order顺序接口的BeanDefinitionRegistryPostProcessor
                postProcessor.postProcessBeanDefinitionRegistry(registry);
            4.最后执行没有实现任何优先级接口或顺序接口的BeanDefinitionRegistryPostProcessor


            再执行BeanFactoryPostProcessor
            1.获取所有的BeanFactoryPostProcessor
            2.看优先级排序PriorityOrdered，先执行实现了这个接口的BeanFactoryPostProcessor
                            postProcessor.postProcessBeanFactory(beanFactory);
                        3.再执行实现了Order顺序接口的BeanFactoryPostProcessor
                            postProcessor.postProcessBeanFactory(beanFactory);
                        4.最后执行没有实现任何优先级接口或顺序接口的BeanFactoryPostProcessor
6.registerBeanPostProcessors(beanFactory);注册BeanPostProcessor（Bean的后置处理器）【intercept bean creation】
        不同接口的BeanPostProcessor，在Bean创建前后的执行时机是不一样的
        BeanPostProcessor、DestructionAwareBeanPostProcessor、
        InstantiationAwareBeanPostProcessor、
        SmartInstantiationAwareBeanPostProcessor、
        MergedBeanDefinitionPostProcessor【internalPostProcessors】
        1.获取所有的BeanPostProcessor，后置处理器都默认可以通过PriorityOrdered、Ordered接口来指定优先级
        2.先注册PriorityOrdered接口的BeanPostProcessor
            把每一个BeanPostProcessor添加到BeanFactory中
            beanFactory.addBeanPostProcessor(postProcessor);
        3.再注册Ordered接口的
        4.最后注册没有实现任何优先级接口的
        5.最终注册MergedBeanDefinitionPostProcessor
        6.注册一个ApplicationListenerDetector，来在Bean创建完成后检查是否是ApplicationListener，如果是
        applicationContext.addApplicationListener((ApplicationListener<?>) bean);
7.initMessageSource()，初始化MessageSource组件(做国际化，消息绑定，消息解析)
        1.获取BeanFactory
        2.看容器中是否有id为messageSource，类型是MessageSource的组件
            如果有赋值给messageSource,如果没有就自己创建一个DelegatingMessageSource
            MessageSource，取出国际化配置文件中某个key的值，能按照区域信息获取
        3.把创建好的MessageSource注册在容器中，以后获取国际化配置文件的时候，可以自动注入messageSource
        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
        MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);
8.initApplicationEventMulticaster();初始化事件派发器
        1.获取BeanFactory
        2.从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster
        3.如果上一步没有配置，就创建一个SimpleApplicationEventMulticaster
        4.将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件可以自动注入
9.onRefresh();留给子容器（子类）
        1.子类重写这个方法，在容器刷新时可以自定义逻辑
10.registerListeners();把容器中将所有项目里面的ApplicationListener注册进来
        1.从容器中拿到所有的ApplicationListener
        2.将每个监听器添加到事件派发器中
            getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
        3.派发之前步骤产生的事件
11.finishBeanFactoryInitialization(beanFactory);初始化所有的剩下的单实例Bean
        1.beanFactory.preInstantiateSingletons();初始化剩下的单实例Bean
            1.获取容器中的所有Bean，依次进行初始化和创建对象
            2.获取Bean的定义信息：RootBeanDefinition
            3.Bean不是抽象的，是单实例的，不是懒加载的
                1.判断是否是FactoryBean，是否是实现FactoryBean接口的Bean
                2.如果不是工厂Bean，利用getBean()创建对象
                    0.getBean(beanName);
                    1.doGetBean(name,null,null,false)
                    2.先获取缓存中保存的单实例Bean，如果能获取到说明这个Bean之前被创建过(所有创建过的单实例Bean都会被缓存起来)
                        从private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);中拿
                    3.缓存中拿不到，就开始Bean的创建对象流程
                    4.标记当前Bean已经被创建
                    5.获取Bean的定义信息
                    6.获取Bean依赖的其他Bean，如果有，按照getBean的方式把依赖的Bean先创建出来




